require("Utils")local sin = math.sinlocal cos = math.coslocal rad = math.radlocal abs = math.abslocal clamp = math.clamplocal floor = math.floorlocal ceil = math.ceillocal random = math.randomlocal round = math.roundCamera = require("Libraries/CameraLib")()ffi = require("ffi")socket = require("socket")enet = require("enet")bitser = require "Libraries/bitser"QDraw = require "Libraries/QDraw"moonshine = require("Libraries/moonshine")sfxr = require("Libraries/sfxr")denver = require("Libraries/denver")easing = require("Libraries/easing")require("CDefs")----_TD = require("Scripts/Types")Types = _TD[1]IDs = _TD[2]Mutations = _TD[3]Groupings = _TD[4]UpdateFuncs = _TD[5]_TLD = require("Scripts/Tiles")Tiles = _TLD[1]TileIDs = _TLD[2]--Effects = require("Scripts/Effects")Settings = require("Scripts/Settings")Music = require("Scripts/Music")GUI = require("Scripts/GUI")----MapMem = love.data.newByteData(ffi.sizeof("MapTile") * ((Settings.MapSize+2)^2))ModuleDataMem = love.data.newByteData(ffi.sizeof("ModuleData"))Map = ffi.cast("MapTile *", MapMem:getFFIPointer())ModuleData = ffi.cast("ModuleData *", ModuleDataMem:getFFIPointer())ModuleData.HalfSize = Settings.UnitSize / 2ModuleData.MapSize = Settings.MapSizeModuleData.CellLimit = Settings.MaxCellCountModuleData.DebrisLimit = Settings.MaxDebrisCountOrganisms = ModuleData.OrganismsCells = ModuleData.CellsDebris = ModuleData.DebrisGenomes = {}GenomeCount = 0FreeGenomeSlots = {}FreeGenomeCount = 0EffectList = {}SonarList = {}-- updated later int he update functionCELLPXSZ = Settings.CellPixelSizeDEBRISPXSZ = Settings.CellPixelSize------------------------------------------------------------------------------------------------------------------------ Important! We fill these lists backwards so that the free slots at the beginning of the arrays are filled first, to keep the update loops only as big as they eed to beModuleData.FreeCellSlotCount = 1000000ModuleData.FreeDebrisSlotCount = 1000000ModuleData.FreeOrganismSlotCount = 1000000FreeGenomeCount = 1000000for i=1000000, 1, -1 do	FreeGenomeSlots[i] = (1000000 - i) + 1	ModuleData.FreeCellSlots[i] = (1000000 - i) + 1	ModuleData.FreeDebrisSlots[i] = (1000000 - i) + 1	ModuleData.FreeOrganismSlots[i] = (1000000 - i) + 1endCamBounds = {x1 = 0, x2 = 0, y1 = 0, y2 = 0}GameCamera = {x = 250, y = 250, scale = 2}EditorCamera = {x = 0, y = 0, scale = 2}BinaryTerrainData = ""function love.touchmoved(id, x, y, dx, dy, pressure)    Camera.x = Camera.x + dx * 1    Camera.y = Camera.y + dy * 1endlove.audio.setVolume(0.1)----------------------------------------------------------------------------------------------------------------------local _AN = {}_AN[1] = {Angle = 315, x = -1, y = -1, Dist = 1.5}_AN[2] = {Angle = 270, x = -1, y = 0, Dist = 1}_AN[3] = {Angle = 225, x = -1, y = 1, Dist = 1.5}_AN[4] = {Angle = 0, x = 0, y = -1, Dist = 1}_AN[5] = {Angle = 180, x = 0, y = 1, Dist = 1}_AN[6] = {Angle = 45, x = 1, y = -1, Dist = 1.5}_AN[7] = {Angle = 90, x = 1, y = 0, Dist = 1}_AN[8] = {Angle = 135, x = 1, y = 1, Dist = 1.5}math.randomseed(os.time())WATCHMODE = falselocal GenomePrefixes = {"Un", "Tera", "Cha", "Chu", "Tyu", "Tsu", "Dasbdh", "Sha Sho", "Vrooma", "Fergna", "CVS Pharmacy"}local GenomeSuffixes = {"Dosalis", "Oppsa", "Figner", "Adadada", "Boo", "Shud", "Fjornso", "Looo", "Popopoo", "Fasiba", "Ptralsa"}local GenomeCallWaveforms = {"sinus", "sawtooth", "square", "triangle"}--, "whitenoise", "pinknoise", "brownnoise"}local GenomeCallNotes = {"C", "D", "E","F", "G", "A", "B"}--, "C#", "D#", "E#","F#", "G#", "A#", "B#", "Cb", "Db", "Eb","Fb", "Gb", "Ab", "Bb"}local SC, Angle, NewX, NewY, AN, ParentIndex, Type, r, g, b, GnClIn, C1, C2, IDX1, IDX2, Parent, OX, OYlocal function CreateGenome()	local NewIndex = FreeGenomeSlots[FreeGenomeCount]	FreeGenomeCount = FreeGenomeCount - 1			GenomeCount = GenomeCount + 1    Genomes[NewIndex] = {		Name = GenomePrefixes[random(1, #GenomePrefixes)].." "..GenomeSuffixes[random(1, #GenomeSuffixes)],		EggType = "Soft Egg",		EggHatchTime = 1,--random(3, 10),		------------------		GeneralMutationProtection = math.randf(0, 99), -- This will increase the threshold required to mutate for every cell (good for organisms that have developed alot already)		------------------		MutationProtectionMap = {}, -- A 2d grid that contains the direction of change for gene volatility per 		GeneVolatilityMap = {}, -- A 2d grid that contains data on mutation vulnerability in cells		------------------		Occupancy = {},		Neurons = {},        Cells = {},		CellCount = 0,		Symmetry = random(1, 4) ~= 1,		CallTimerMax = random(2, 15),		Calllength = math.randf(0.3, 3.5),		------------------		Mutate = function(self)			-- New Cell			for i=1, random(0, 1) do				self:AddRandomChild()							end							-- Mutate existing			for i=1, random(0, 1) do						-- Starts at 2, we dont ever modify the core				self.Cells[random(2, #self.Cells)].Type = IDs["Cell"][random(2, #IDs["Cell"])]			end									self.CallTimerMax = clamp(self.CallTimerMax + math.randf(-1, 1), 25, 360)			self.Calllength = clamp(self.Calllength + math.randf(-0.1, 0.1), 0.2, 5)		end,        AddRandomChild = function(self)			ParentIndex = random(1, #self.Cells)            SC = self.Cells[ParentIndex]			if SC.ChildCount < 3 then				Type = IDs["Cell"][random(2, #IDs["Cell"])]				AN = _AN[3]--_AN[random(1, 8)]				NewX = SC.x + AN.x				NewY = SC.y + AN.y					OX = AN.x				OY = AN.y				if self.Occupancy[(NewX * Settings.OccuMapSize) + NewY] == nil then					r = clamp(SC.r + math.randf(-0.1, 0.1), 0.1, 1)					g = clamp(SC.g + math.randf(-0.1, 0.1), 0.1, 1)					b = clamp(SC.b + math.randf(-0.1, 0.1), 0.1, 1)					if not self.Symmetry then						self:NewEntry(NewX, NewY, OX, OY, Type, ParentIndex, AN.Dist, r, g, b)					elseif NewX == 0 then						self:NewEntry(NewX, NewY, OX, OY, Type, ParentIndex, AN.Dist, r, g, b)					elseif SC.ChildCount <= 1 then						IDX1 = self:NewEntry(-NewX, NewY, -OX, OY, Type, SC.Twin, AN.Dist, r, g, b)						IDX2 = self:NewEntry(NewX, NewY, OX, OY, Type, ParentIndex, AN.Dist, r, g, b)						C1 = self.Cells[IDX1]						C2 = self.Cells[IDX2]						C1.Twin = IDX2						C2.Twin = IDX1															end				end			end        end,		NewEntry = function(self, x, y, ox, oy, Type, Parent, ConnectionDist, cr, cg, cb)			if Parent ~= 0 then				self.Cells[Parent].ChildCount = self.Cells[Parent].ChildCount + 1			end			GnClIn = #self.Cells+1			self.Cells[GnClIn] = {				x = x,				y = y,				ox = ox,				oy = oy,				Type = Type,				Parent = Parent,				ConnectionDist = ConnectionDist,				ChildCount = 0,				r = cr, g = cg, b = cb,				Twin = GnClIn, --By default make the 'twin' as self index so on non symettrical cells, tgheir symmetrical children will just double parent			}					self.CellCount = self.CellCount + 1			self.Occupancy[(x * Settings.OccuMapSize) + y] = true					return			GnClIn		end,		Draw = function(self, x, y, size)					love.graphics.push()						local MaxSize = 0						for k, v in pairs(self.Cells) do				if abs(v.x) > MaxSize then					MaxSize = abs(v.x)				end				if abs(v.y) > MaxSize then					MaxSize = abs(v.y)				end							end						local Incr = (size / MaxSize) / 2			local CellScale = (Incr / CELLPXSZ) * 4					for k, v in pairs(self.Cells) do								love.graphics.setColor(v.r, v.g, v.b)				love.graphics.draw(					Types["Cell"][v.Type].Image, 					x+(v.x*Incr), 					y+(v.y*Incr), 					0, 					CellScale / MaxSize, 					CellScale / MaxSize, 					CELLPXSZ/2, 					CELLPXSZ/2				)			end						love.graphics.pop()				end,    }		local GNM = Genomes[NewIndex]		GNM:NewEntry(0, 0, 0, 0, "Core", 0, 0, 		math.randf(0.1, 1),		math.randf(0.1, 1),		math.randf(0.1, 1)	)	print("New Organism", NewIndex)    return NewIndexend		local function CreateOrganism(GenomeIndex, SpawnX, SpawnY)				if ModuleData.CellCount < Settings.MaxCellCount then			local Genome = Genomes[GenomeIndex]	    if GenomeIndex == nil then        GenomeIndex = CreateGenome()		Genome = Genomes[GenomeIndex]				for i=1, random(1, 8) do			            Genome:AddRandomChild()			        end	else		Genome:Mutate()    end	if ModuleData.FreeOrganismSlotCount > 0 and ModuleData.FreeCellSlotCount >= Genome.CellCount then		local OrganismIndex = ModuleData.FreeOrganismSlots[ModuleData.FreeOrganismSlotCount]		ModuleData.FreeOrganismSlotCount = ModuleData.FreeOrganismSlotCount - 1		if OrganismIndex > ModuleData.OrganismListSize then					ModuleData.OrganismListSize = OrganismIndex		end		ModuleData.OrganismCount = ModuleData.OrganismCount + 1				local OrgTbl = Organisms[OrganismIndex]		OrgTbl.Alive = 1		OrgTbl.Dying = 0		OrgTbl.Health = 0		OrgTbl.HealthMax = 0		OrgTbl.Energy = 0		OrgTbl.EnergyMax = 0		OrgTbl.EnergyLossSec = 0		OrgTbl.Age = 0		OrgTbl.CoreIndex = 0		OrgTbl.MoveX = 0		OrgTbl.MoveY = 0		OrgTbl.MoveR = 0		OrgTbl.XVel = 0		OrgTbl.YVel = 0		OrgTbl.RVel = 0		OrgTbl.Rot = 0		OrgTbl.CellCount = Genome.CellCount		OrgTbl.EggType = Types["Debris"][Genome.EggType].ID		OrgTbl.EggHatchTime = Genome.EggHatchTime		OrgTbl.GenomeIndex = GenomeIndex		OrgTbl.EggCost = 0		OrgTbl.Index = OrganismIndex		OrgTbl.CallTimer = random(0, 15)		OrgTbl.CallTimerMax = Genome.CallTimerMax		OrgTbl.CallDuration = Genome.Calllength				-- Create all the cells from the genome first		for k, v in pairs(Genome.Cells) do						v.CreatedCell = CreateCell(OrganismIndex, v.Type, v.ox, v.oy, v.ConnectionDist, SpawnX+v.x, SpawnY+v.y, v.r, v.g, v.b)						if v.Type == "Core" then			   OrgTbl.CoreIndex = v.CreatedCell.Index			   v.CreatedCell.BaseRot = random(0, 360)			end							OrgTbl.Health = OrgTbl.Health + Types["Cell"][v.Type].Health			OrgTbl.HealthMax = OrgTbl.HealthMax + Types["Cell"][v.Type].Health			OrgTbl.Energy = OrgTbl.Energy + Types["Cell"][v.Type].EnergyCapacity			OrgTbl.EnergyMax = OrgTbl.EnergyMax + Types["Cell"][v.Type].EnergyCapacity			OrgTbl.EnergyLossSec = OrgTbl.EnergyLossSec + Types["Cell"][v.Type].EnergyCostPerSec			OrgTbl.EggCost = OrgTbl.EggCost + Types["Cell"][v.Type].EnergyCostPerSec*2		end				-- Second, link all the children to their parents		for k, v in pairs(Genome.Cells) do			if k == 1 then -- Skip the core cell since it wont have a parent				v.CreatedCell.IsCore = 1			else				local ParentGenCell = Genome.Cells[v.Parent]				local ParentCell = ParentGenCell.CreatedCell				ParentCell.Children[ParentCell.ChildCount] = v.CreatedCell.Index				ParentCell.ChildCount = ParentCell.ChildCount + 1			end		end		return OrganismIndex	end	endendfunction CreateCell(OrganismID, Type, ox, oy, ConnectionDist, x, y, r, g, b)	if ModuleData.FreeCellSlotCount > 0 then		local NewIndex = ModuleData.FreeCellSlots[ModuleData.FreeCellSlotCount]		ModuleData.FreeCellSlotCount = ModuleData.FreeCellSlotCount - 1				if NewIndex > ModuleData.CellListSize then					ModuleData.CellListSize = NewIndex		end		ModuleData.CellCount = ModuleData.CellCount + 1		Cells[NewIndex].Index = NewIndex		Cells[NewIndex].Class = 0 -- 0 - cell, 1 - debris, 2 - organism		Cells[NewIndex].TypeID = Types["Cell"][Type].ID		Cells[NewIndex].OrganismID = OrganismID				Cells[NewIndex].Armor = Types["Cell"][Type].Armor		Cells[NewIndex].x = x		Cells[NewIndex].y = y		Cells[NewIndex].ox = ox		Cells[NewIndex].oy = oy		Cells[NewIndex].ParentRot = 0 -- The rotation of this cells parent		Cells[NewIndex].BaseRot = 0 -- The base rotation of this cell		Cells[NewIndex].Bend = 0 -- This cells dynamic change to its base rotation		Cells[NewIndex].Rot = 0 -- The real world rotation of this cell		Cells[NewIndex].ix = x		Cells[NewIndex].iy = y		Cells[NewIndex].iRot = 0		Cells[NewIndex].tx = 1		Cells[NewIndex].ty = 1		Cells[NewIndex].IsCore = 0		Cells[NewIndex].ConnectionDist = ConnectionDist		Cells[NewIndex].PullX = 0		Cells[NewIndex].PullY = 0		Cells[NewIndex].ConnX = 0		Cells[NewIndex].ConnY = 0		Cells[NewIndex].XVel = 0		Cells[NewIndex].YVel = 0		Cells[NewIndex].PushX = 0		Cells[NewIndex].PushY = 0		Cells[NewIndex].Rooted = 0		Cells[NewIndex].Alive = 1		Cells[NewIndex].Tile = 1		Cells[NewIndex].TileSlot = 255		Cells[NewIndex].TileIncrementTimer = 0					Cells[NewIndex].ChildCount = 0		for i=0, 2 do			Cells[NewIndex].Children[i] = 0			Cells[NewIndex].ChildAngles[i] = 0		end		Cells[NewIndex].Color[0] = r		Cells[NewIndex].Color[1] = g		Cells[NewIndex].Color[2] = b				-- Rerouting the data to be useful to the c script		local UF = UpdateFuncs[Types["Cell"][Type].UpdateType]		Cells[NewIndex].UpdateTypeID = UF.ID		for i=0, 3 do			Cells[NewIndex].CustomData[i] = Types["Cell"][Type].CustomCData[i+1]		end		return Cells[NewIndex]	endendlocal function CreateDebris(Type, x, y, EggGenome, HatchTimerMax)    -- Debris will only collide with terrain and cells, and when it collides with cells it will not apply any force to them,    -- it will only be pushed away.	if ModuleData.FreeDebrisSlotCount > 0 then		NewIndex = ModuleData.FreeDebrisSlots[ModuleData.FreeDebrisSlotCount]		ModuleData.FreeDebrisSlotCount = ModuleData.FreeDebrisSlotCount - 1		if NewIndex > ModuleData.DebrisListSize then					ModuleData.DebrisListSize = NewIndex		end		ModuleData.DebrisCount = ModuleData.DebrisCount + 1				--print("DEBRIS", "Index", NewIndex)		Debris[NewIndex].Index = NewIndex		Debris[NewIndex].Class = 1 -- 0 - cell, 1 - debris, 2 - organism		Debris[NewIndex].TypeID = Types["Debris"][Type].ID		Debris[NewIndex].x = x		Debris[NewIndex].y = y		Debris[NewIndex].Rot = random(0, 360)		Debris[NewIndex].ix = x		Debris[NewIndex].iy = y		Debris[NewIndex].iRot = 0		Debris[NewIndex].Spin = random(0, 25)		Debris[NewIndex].XVel = 0		Debris[NewIndex].YVel = 0		Debris[NewIndex].LifeTime = random(10, 30)		if EggGenome ~= nil then			Debris[NewIndex].EggGenomeID = EggGenome			Debris[NewIndex].HatchTimer = 0			Debris[NewIndex].HatchTimerMax = HatchTimerMax		else			Debris[NewIndex].EggGenomeID = 0			Debris[NewIndex].HatchTimer = 0			Debris[NewIndex].HatchTimerMax = 0		end		Debris[NewIndex].Active = 1			end	returnNewIndexendMapDuration = 0GeneratingMap = falselocal RM, RM2local mtx, mty = 1, 1local function StartMapGen()	math.randomseed(socket.gettime())	RM = math.random(1, 99999) + 0.1	RM2 = math.random(1, 99999) + 0.1	GeneratingMap = true	mtx = 0	mty = 0	TerrainCanvas = nilendlocal function CreateMap()	if GeneratingMap then		local Index, x, y, NX, NY, NV, DTB, CSTR, TNTR, MN		for i=1, Settings.MapBuildInterval do			x = mtx			y = mty			Index = (x * Settings.MapSize) + y			NX = x * 0.01			NY = y * 0.01			NV = love.math.noise(RM + NX, RM + NY)						DTB = y / Settings.MapSize -- Distance to bottom			Map[Index].Sunlight = clamp(100-(DTB*160), 0, 100) / 100			Map[Index].Temperature = clamp((75-(DTB*175))+(NV*50), -100, 100)			Map[Index].Pressure = clamp(0.1+DTB, 0, 1)			Map[Index].Salinity = love.math.noise(RM2 + NX, RM2 + NY)			Map[Index].Oxygen = clamp((100-(DTB*85))+random(-2, 2), 0, 100) / 100							Map[Index].Bucket[0] = 0			Map[Index].Bucket[1] = 0			Map[Index].Bucket[2] = 0			Map[Index].Bucket[3] = 0			Map[Index].Bucket[4] = 0			Map[Index].Bucket[5] = 0			Map[Index].Bucket[6] = 0			Map[Index].Bucket[7] = 0			Map[Index].Occupancy = 0	   			CSTR = 500			Map[Index].Color[0] = love.math.noise((x+40)/CSTR, y/CSTR)			Map[Index].Color[1] = love.math.noise(x/CSTR, (y+40)/CSTR)			Map[Index].Color[2] = love.math.noise((x+90)/CSTR, (y+90)/CSTR)						TNTR = 100			Map[Index].BgTint = love.math.noise((x+1341)/TNTR, (y+414)/TNTR) * 0.1						local TileType = ""			if x % 4 == 0 and y % 4 == 0 then				if NV - 0.35 >= 0.3 then					MN = love.math.noise(x/500, y/500)					TileType = Tiles["_"..round(MN * 240)].ID				else					TileType = 0				end				if x < 35 or y < 85 or x > Settings.MapSize-35 then					TileType = 0				end				for tx = x, x + 3 do					for ty = y, y + 3 do						Map[(tx * Settings.MapSize) + ty].Terrain = TileType					end				end			end						mtx = mtx + 1			if mtx == Settings.MapSize-1 then				mtx = 0				mty = mty + 1				if mty == Settings.MapSize-1 then					GeneratingMap = false					break				end			end		end	endendlocal NewCellTimer = 0local function PeriodicNewCells(dt)		NewCellTimer = NewCellTimer - dt		--if NewCellTimer <= 0 then		NewCellTimer = 0				for i=1, 1000 do			if ModuleData.CellCount < Settings.MaxSpawnedCellCount then				local RandX, RandY				RandX = random(10, Settings.MapSize-10)				RandY = random(10, Settings.MapSize-10)				if Map[(RandX * Settings.MapSize) + RandY].Terrain == 0 then					CreateOrganism(nil, RandX, RandY)				end			end			end	--end		local RandomDebris = {"Algae", "Meat", "Sugar", "Veggie"}	if ModuleData.DebrisCount < Settings.MaxSpawnedDebrisCount then		local RandX = random(10, Settings.MapSize)		local RandY = random(10, Settings.MapSize)		if Map[(RandX * Settings.MapSize) + RandY].Terrain == 0 then			CreateDebris(RandomDebris[random(1, #RandomDebris)], RandX, RandY)		end	end		end----------------------------------------------------------------------------------------------------------------------function UpdateCells(dt)			-- Free any genomes	local Index	for i=1, ModuleData.GenomeRemovalsCount do		Index = ModuleData.GenomeRemovals[i]		Genomes[Index] = nil		FreeGenomeCount = FreeGenomeCount + 1		FreeGenomeSlots[FreeGenomeCount] = Index			GenomeCount = GenomeCount - 1	end	ModuleData.GenomeRemovalsCount = 0		local v	for k=1, ModuleData.DebrisListSize do		v = Debris[k]		if v.Active == 1 and v.EggGenomeID ~= 0 and v.HatchTimer >= v.HatchTimerMax then			Debris[k].Active = 0			ModuleData.FreeDebrisSlotCount = ModuleData.FreeDebrisSlotCount + 1			ModuleData.FreeDebrisSlots[ModuleData.FreeDebrisSlotCount] = k			ModuleData.DebrisCount = ModuleData.DebrisCount - 1			CreateOrganism(v.EggGenomeID, v.x, v.y)			end	end			-- Effects	local i = 0	local e	local NewIndex	for i=1, ModuleData.EffectCount do		e = ModuleData.Effects[i]		NewIndex = #EffectList+1		EffectList[NewIndex] = {			Color = Effects[e.Type].Color,			Text = Effects[e.Type].Text,			Sound = Effects[e.Type].Sound:clone(),			Texture = Effects[e.Type].Texture,			x = e.x,			y = e.y,			scale = 0,			lifetime = 0		}		--EffectList[NewIndex].Sound:play()	end	ModuleData.EffectCount = 0	endfunction love.load(args)    MODE = "Server"    --if MODE == "Server" then	StartMapGen()   -- CreateRandomCellList(Settings.UnitCount)    --end    print("Starting as ", MODE)end------_GlobalDT = 0------local dff = falseUpdatesPerSecond = 30UpdateTimer = 0UpdateRate = 1 / UpdatesPerSecondUpdateThreadCount = 1UpdateThreads = {}ThreadFinishes = UpdateThreadCountLastThreadTime = 0ThreadTime = 0RealUpdateRate = 0PAUSE = falseTURBO = falsePauseRefreshed = truefor i=1, UpdateThreadCount do	UpdateThreads[i] = love.thread.newThread(love.filesystem.read("Threads/ProcessUnits.lua"))	UpdateThreads[i]:start(MapMem, ModuleDataMem)endfunction love.update(dt)    dt = clamp(dt, 0, 0.2)    _GlobalDT = dt		ModuleData.Gravity = Settings.Gravity		UpdateRate = clamp(UpdateRate, 0.001, 1)			while love.thread.getChannel("Thread Finishes"):pop() ~= nil do		ThreadFinishes = ThreadFinishes + 1	end		if not PAUSE then		if not TURBO then			UpdateTimer = UpdateTimer + dt		else			UpdateTimer = UpdateRate		end		if UpdateTimer >= UpdateRate then			if ThreadFinishes == UpdateThreadCount then					for i=1, UpdateThreadCount do					love.thread.getChannel("Thread Updates"):push({UpdateTimer, UpdateRate})				end				ThreadFinishes = 0				UpdateCells(dt)				MapDuration = MapDuration + UpdateTimer				UpdateTimer = 0			end		end		PeriodicNewCells(dt)	end		CreateMap()	Music.PlayMix(dt)	    if love.keyboard.isDown("escape") then        love.event.quit()    end			CELLPXSZ = Settings.CellPixelSize	DEBRISPXSZ = Settings.CellPixelSizeendlocal Backgrounds = {}Backgrounds["Test"] = {}Backgrounds["Test"][1] = love.graphics.newImage("Assets/Backgrounds/Test_1.png")Backgrounds["Test"][2] = love.graphics.newImage("Assets/Backgrounds/Test_2.png")Backgrounds["Test"][3] = love.graphics.newImage("Assets/Backgrounds/Test_3.png")for k, v in pairs(Backgrounds["Test"]) do	v:setFilter("nearest", "nearest")endlocal UVScrollShader = love.graphics.newShader [[	uniform float PanX;	uniform float PanY;	uniform float PanMod;    vec4 effect( vec4 color, Image tex, vec2 texture_coords, vec2 screen_coords)    {			float coordx = mod((texture_coords.x*32.0)+(PanX*PanMod), 1.0);		float coordy = mod((texture_coords.y*32.0)+(PanY*PanMod), 1.0);        vec4 texcolor = Texel(tex, vec2(coordx, coordy));        return texcolor * color;    }]]local ParallaxPanVal = 0local SinVal = 0LightTexture = love.graphics.newImage("Assets/LightTexture.png", {mipmaps = true})LightTexture:setMipmapFilter("linear", 1)LightTexture:setFilter("linear", "linear")CellCover = love.graphics.newImage("Assets/Cell Cover.png")BlankTexture = love.graphics.newImage("Assets/Blank Tile.png")LineTexture = love.graphics.newImage("Assets/_Link.png", {mipmaps = true})LineTexture:setMipmapFilter("nearest", 1)LineTexture:setFilter("nearest", "nearest")MonitorTexture = love.graphics.newImage("Assets/Monitors/Base.png", {mipmaps = true})-- returns the direction from point x1,y1 to x2,y2 (in radians)function direction(x1, y1, x2, y2)	return math.atan2(y2-y1, x2-x1)end-- returns the distance between points x1,y1 and x2,y2function distance(x1, y1, x2, y2)	return math.sqrt(((x2-x1)^2)+((y2-y1)^2))endlocal MonitorCanvasSize = 720local MonitorCanvas = love.graphics.newCanvas(MonitorCanvasSize, MonitorCanvasSize, {msaa = 4})MonitorCanvas:setFilter("nearest", "nearest")EnvironmentOverlayIndex = 1EnvironmentOverlays = {"Sunlight", "Temp", "Pressure", "Salinity", "Oxygen"}local SunlightImagelocal TemperatureImagelocal PressureImagelocal SalinityImagelocal OxygenImagelocal TerrainImageGameEffect = moonshine(moonshine.effects.glow)	.chain(moonshine.effects.filmgrain)	.chain(moonshine.effects.chromasep)	.chain(moonshine.effects.crt)GameEffect.filmgrain.size = 1GameEffect.crt.distortionFactor = {1.1, 1.1}GameEffect.glow.min_luma = 0.7ScreenEffect = moonshine(moonshine.effects.glow)	.chain(moonshine.effects.chromasep)	.chain(moonshine.effects.crt)ScreenEffect.crt.distortionFactor = {1.2, 1.2}HUDEffect = moonshine(moonshine.effects.glow)	.chain(moonshine.effects.chromasep)GameCanvas = love.graphics.newCanvas(love.graphics.getWidth(), love.graphics.getHeight())HUDCanvas = love.graphics.newCanvas(love.graphics.getWidth(), love.graphics.getHeight())function DrawParallax()	local w, h = Backgrounds["Test"][1]:getWidth(), Backgrounds["Test"][1]:getWidth()	ParallaxPanVal = ParallaxPanVal + _GlobalDT * 0.005	local PanX = Camera.x * 0.001	local PanY = Camera.y * 0.001	UVScrollShader:send("PanX", ParallaxPanVal - PanX)	UVScrollShader:send("PanY", ParallaxPanVal - PanY)	love.graphics.setShader(UVScrollShader)		if love.keyboard.isDown("k") then test = test - _GlobalDT end	if love.keyboard.isDown("l") then test = test + _GlobalDT end		love.graphics.setColor(1, 1, 1, 1)		UVScrollShader:send("PanMod", 2)	love.graphics.draw(Backgrounds["Test"][1], 0, 0, 0, Settings.MapSize / w, Settings.MapSize / h)		UVScrollShader:send("PanMod", 0.5)	love.graphics.draw(Backgrounds["Test"][2], 0, 0, 0, Settings.MapSize / w, Settings.MapSize / h)	UVScrollShader:send("PanMod", 0.9)	love.graphics.draw(Backgrounds["Test"][3], 0, 0, 0, Settings.MapSize / w, Settings.MapSize / h)	love.graphics.setShader()	endfunction DrawOrganisms()	local CenterX, CenterY = Camera:toWorldCoords(love.graphics.getWidth()/2, love.graphics.getHeight()/2)	local Org, CoreCell, OrgGenome	for k=1, ModuleData.OrganismListSize do		Org = Organisms[k]		CoreCell = Cells[Org.CoreIndex]		OrgGenome = Genomes[Org.GenomeIndex]				if OrgGenome ~= nil then			if FreeGenomeCount > 0 and Org.Energy == Org.EnergyMax+Org.EggCost and ModuleData.DebrisCount < ModuleData.DebrisLimit then			--if FreeGenomeCount > 0 and Org.Energy >= Org.EnergyMax+Org.EggCost and ModuleData.DebrisCount < ModuleData.DebrisLimit then				Org.Energy = Org.Energy - Org.EggCost				local GenomeCopyIndex = FreeGenomeSlots[FreeGenomeCount]				FreeGenomeCount = FreeGenomeCount - 1						GenomeCount = GenomeCount + 1				Genomes[GenomeCopyIndex] = table.copy(OrgGenome)							CreateDebris(IDs["Debris"][Org.EggType], CoreCell.x, CoreCell.y, GenomeCopyIndex, Org.EggHatchTime)			end 						if Org.Calling == 1 then							local Progress = Org.CallProgress / Org.CallDuration				local MaxDist = 100				local Dist = distance(Org.CallX, Org.CallY, CenterX, CenterY)				local Vol = clamp(1 - (Dist / MaxDist), 0, 1)				--OrgGenome.CallSource:setVolume(Vol)											love.graphics.setColor(CoreCell.Color[0], CoreCell.Color[1], CoreCell.Color[2], 1-Progress)				love.graphics.circle("line", Org.CallX, Org.CallY, Org.CallProgress*12)			end		end	endendfunction DrawCells()	love.graphics.setLineWidth(0.01)	local k, v, b, DS = 0, 0, 0, Settings.UnitSize / (86/4)	SinVal = SinVal + _GlobalDT * 3			local CellScale = ((1 / CELLPXSZ) * Settings.UnitSize) * 1.8 -- mult at the end is used to oversize it a bit	local DesiredUpdateRate = RealUpdateRate/_GlobalDT	local WobbleStrength = 0.1	local USX1, USY1, USX2, USY2	local LH = LineTexture:getHeight()	local OX = CELLPXSZ / 2	local OY = CELLPXSZ / 2	for i=1, ModuleData.Safe_CellRenderCount do		k = ModuleData.CellRenderList[i]		v = Cells[k]			if v.Alive == 1 then			if abs(v.ix-v.x) > 4 then				v.ix = v.x			end			if abs(v.iy-v.y) > 4 then				v.iy = v.y			end			v.ix = lerp(v.ix, v.x, _GlobalDT * 30)			v.iy = lerp(v.iy, v.y, _GlobalDT * 30)			love.graphics.setColor(				v.Highlighting+v.Color[0], 				v.Highlighting+v.Color[1], 				v.Highlighting+v.Color[2]			)			-- Draw cell			love.graphics.draw(				Types["Cell"][IDs["Cell"][v.TypeID]].Image, 				v.ix + sin(SinVal*10) * v.Shaking * 0.1, 				v.iy - cos((SinVal*12) + 7) * v.Shaking * 0.1, 				rad(v.Rot), 				CellScale * 1, 				CellScale * 1, 				OX, 				OY			)		end	endendfunction DrawDebris()	local DS = (1 / 16) * 2	for i=1, ModuleData.Safe_DebrisRenderCount do				k = ModuleData.DebrisRenderList[i]		v = Debris[k]				--print(v.TypeID, v.LifeTime, v.EggGenomeID, v.TypeID, v.Active, ModuleData.Safe_DebrisRenderCount, i, k, ModuleData.DebrisCount)				if v.Active == 1 then					-- Lerp the visual x and y to the actual x and y position			if abs(v.ix-v.x) > 4 then				v.ix = v.x			end			if abs(v.iy-v.y) > 4 then				v.iy = v.y			end			v.ix = lerp(v.ix, v.x, _GlobalDT * 30)			v.iy = lerp(v.iy, v.y, _GlobalDT * 30)						love.graphics.setColor(1, 1, 1)						--love.graphics.circle("line", v.ix, v.iy, 0.99/2)			love.graphics.draw(Types["Debris"][IDs["Debris"][v.TypeID]].Image, v.ix, v.iy, rad(v.Rot), DS, DS, 8, 8)			--love.graphics.print(string.format("%.2f",v.x).." - "..string.format("%.2f",v.y), v.ix+1, v.iy+1, 0, 0.03, 0.03)		end	endendfunction DrawMap()	local TileType, TileIndex		if TerrainCanvas == nil and not GeneratingMap then		love.graphics.push()		love.graphics.origin()		love.graphics.clear(0, 0, 0, 0)		TerrainCanvas = love.graphics.newCanvas(Settings.MapSize*4, Settings.MapSize*4)		love.graphics.setCanvas(TerrainCanvas)			for x=1, Settings.MapSize do				for y=1, Settings.MapSize do														TileIndex = (x * Settings.MapSize) + y						TileType = Map[TileIndex].Terrain								local Color = Map[TileIndex].Color													if TileType ~= 0 and TileType ~= nil then						if x % 4 == 1 and y % 4 == 1 then														local SNV = clamp((Map[TileIndex].Sunlight), 0.1, 1)														local Tint = Map[TileIndex].BgTint							love.graphics.setColor(Tint*SNV, Tint*SNV, Tint*SNV, 1)							love.graphics.rectangle("fill", x*4, y*4, 16, 16)														love.graphics.setColor((0.3+Color[0])*SNV,(0.3+ Color[1])*SNV, (0.3+Color[2])*SNV, 1)							love.graphics.draw(Tiles[TileIDs[TileType]].Img, x*4, y*4, 0, 1, 1)													end					else						if Map[(x * Settings.MapSize) + y].Occupancy ~= 0 then							--love.graphics.print(x.." - "..y, x+0.05, y, 0, 0.015, 0.015)							--love.graphics.rectangle("line", x, y, 1, 1)							--love.graphics.print(Occupancy[(x * Settings.MapSize) + y], x, y, 0, 0.05, 0.05)							for i = 1, 8 do								--love.graphics.print(Buckets[(x * Settings.MapSize) + y][i], x+0.05, y+(i*0.1), 0, 0.01, 0.01)							end						end					end									end			end		love.graphics.setCanvas()		TerrainCanvas:setFilter("nearest", "nearest")	end		if SunlightImage == nil and not GeneratingMap then		love.graphics.push()		love.graphics.origin()		love.graphics.clear(0, 0, 0, 0)		SunlightImage = love.image.newImageData(Settings.MapSize, Settings.MapSize)		TemperatureImage = love.image.newImageData(Settings.MapSize, Settings.MapSize)		PressureImage = love.image.newImageData(Settings.MapSize, Settings.MapSize)		SalinityImage = love.image.newImageData(Settings.MapSize, Settings.MapSize)		OxygenImage = love.image.newImageData(Settings.MapSize, Settings.MapSize)						local Opacity = 0.4		local TileType, TileIndex				for x=1, Settings.MapSize do			for y=1, Settings.MapSize do				Tile = Map[(x * Settings.MapSize) + y]				SunlightImage:setPixel(x-1, y-1, Tile.Sunlight, Tile.Sunlight*(216/255), 0, Opacity)								if Tile.Temperature >= 0 then					TemperatureImage:setPixel(x-1, y-1, abs(Tile.Temperature)/300, 0, 0, Opacity)				else					TemperatureImage:setPixel(x-1, y-1, 0, 0, abs(Tile.Temperature)/300, Opacity)				end								PressureImage:setPixel(x-1, y-1, 0.8*Tile.Pressure, 0.8*Tile.Pressure, 1*Tile.Pressure, Opacity)								SalinityImage:setPixel(x-1, y-1, Tile.Salinity*0.5, Tile.Salinity, Tile.Salinity, Opacity)								OxygenImage:setPixel(x-1, y-1, Tile.Oxygen*0.5, Tile.Oxygen*0.7, Tile.Oxygen, Opacity)			end		end		SunlightImage = love.graphics.newImage(SunlightImage)		TemperatureImage = love.graphics.newImage(TemperatureImage)		PressureImage = love.graphics.newImage(PressureImage)		SalinityImage = love.graphics.newImage(SalinityImage)		OxygenImage = love.graphics.newImage(OxygenImage)				love.graphics.pop()	end			if not GeneratingMap then		if TerrainCanvas ~= nil then			love.graphics.draw(TerrainCanvas , 0, 0, 0, 0.25, 0.25)		end				local OverlayType = EnvironmentOverlays[EnvironmentOverlayIndex]		if OverlayType == "Sunlight" then			love.graphics.draw(SunlightImage, 0, 0)				elseif OverlayType == "Temp" then			love.graphics.draw(TemperatureImage, -1, -1)			elseif OverlayType == "Pressure" then			love.graphics.draw(PressureImage, -1, -1)				elseif OverlayType == "Salinity" then			love.graphics.draw(SalinityImage, -1, -1)			elseif OverlayType == "Oxygen" then			love.graphics.draw(OxygenImage, -1, -1)				end	endendlove.audio.setEffect("coolchorus", {type="chorus",volume=1,waveform="sine",phase=167.23404255319,rate=.085005784417283,depth=.77340174035511,feedback=.43503847894975,delay=.0078902198584161})love.audio.setEffect("coolreverb", {type="reverb",volume=1,density=.62553719008264,diffusion=.71479338842975,gain=.71479338842975,highgain=.27801652892562,decaytime=4.6980387335427,decayhighratio=.46272727272727,earlygain=.009401652892562,earlydelay=.018074380165289,lategain=.64793388429752,latedelay=.009,airabsorption=.99116363636364,roomrolloff=2.7272727272727,highlimit=true})love.audio.setEffect("coolecho", {type="echo",volume=.41202520087655,delay=.0870942293645,tapdelay=.1,damping=0,feedback=.39485938641344,spread=1})love.audio.setEffect("myEffect", {type="reverb"})function DrawEffects(CAMX, CAMY)	local CenterX, CenterY = Camera:toWorldCoords(love.graphics.getWidth()/2, love.graphics.getHeight()/2)		local EffectLifeTime = 1.5	for k, v in pairs(EffectList) do		love.graphics.setColor(v.Color[1], v.Color[2], v.Color[3], 1-(1*(v.lifetime/EffectLifeTime)))		if not v.Sound:isPlaying() and v.scale >= 1 and v.lifetime > EffectLifeTime then			EffectList[k] = nil		end		v.Sound:setVolume(clamp(1-((abs(v.x-CenterX)+abs(v.y-CenterY))*0.001), 0, 1))					v.scale = v.scale + _GlobalDT * 16		v.lifetime = v.lifetime + _GlobalDT		if v.scale < 1 then			love.graphics.draw(v.Texture, v.x, v.y, 0, v.scale*0.5, v.scale*0.5, 8, 8)		end		love.graphics.print(v.Text, v.x-1, v.y-4, 0, 0.1, 0.1)	end	love.graphics.setColor(1, 1, 1, 1)endfunction love.resize(w, h)	GameCanvas = love.graphics.newCanvas(w, h)	HUDCanvas = love.graphics.newCanvas(w, h)endfunction love.draw()			love.graphics.setDefaultFilter("nearest", "nearest", 1)		-- Clamping for slow rendering	_GlobalDT = clamp(_GlobalDT, 0, 1/60)		if love.keyboard.isDown("space") then		if PauseRefreshed then			PAUSE = not PAUSE			print(PAUSE)		end		PauseRefreshed = false	else		PauseRefreshed = true	end		if love.keyboard.isDown("q") then		GameCamera.scale = math.clamp(lerp(GameCamera.scale, Settings.MinZoom, _GlobalDT), Settings.MinZoom, Settings.MaxZoom)	elseif love.keyboard.isDown("e") then		GameCamera.scale = math.clamp(lerp(GameCamera.scale, Settings.MaxZoom, _GlobalDT), Settings.MinZoom, Settings.MaxZoom)	end	local MoveIncr = _GlobalDT * (Settings.PanSpeed / GameCamera.scale)	if love.keyboard.isDown("w") then		GameCamera.y = GameCamera.y - MoveIncr	elseif love.keyboard.isDown("s") then		GameCamera.y = GameCamera.y + MoveIncr	end	if love.keyboard.isDown("a") then		GameCamera.x = GameCamera.x - MoveIncr	elseif love.keyboard.isDown("d") then		GameCamera.x = GameCamera.x + MoveIncr	end	Camera.scale = GameCamera.scale	Camera.x = lerp(Camera.x, GameCamera.x, _GlobalDT*4)	Camera.y = lerp(Camera.y, GameCamera.y, _GlobalDT*4)	Camera:update(_GlobalDT)	Camera:attach()	love.graphics.setLineWidth(0.05)	love.graphics.setColor(0.6, 0.6, 0.8)	local ScreenW = love.graphics.getWidth()	local ScreenH = love.graphics.getHeight()		local CenterX, CenterY = Camera:toWorldCoords(love.graphics.getWidth()/2, love.graphics.getHeight()/2)	local XMin, YMin = Camera:toWorldCoords(0, 0)	local XMax, YMax = Camera:toWorldCoords(love.graphics.getWidth(), love.graphics.getHeight())	ModuleData.CamBounds[0] = XMin	ModuleData.CamBounds[1] = XMax	ModuleData.CamBounds[2] = YMin	ModuleData.CamBounds[3] = YMax	--love.graphics.setBlendMode("alpha", "premultiplied")	--love.graphics.setCanvas(MonitorCanvas)	love.graphics.clear(0, 0, 0, 0)			love.graphics.setColor(1, 1, 1)	GameEffect(function()	DrawParallax()	DrawMap()	love.graphics.setBlendMode("alpha")		DrawCells()	DrawDebris()	DrawEffects(CenterX, CenterY)	DrawOrganisms()		--[[	local str = ""	for i=1, 100 do		str = str ..ModuleData.Safe_DebrisRenderList[i]..", "	end	print(str)	print("X----------------X")	for i=1, 100 do		str = str ..ModuleData.DebrisRenderList[i]..", "	end	print(str)	error()	]]				love.graphics.setColor(1, 1, 1)				local LW = LightTexture:getWidth()	local LS = (Settings.UnitSize / LW) * 5	--[[	for i=1, ModuleData.Safe_CellRenderCount do		k = ModuleData.Safe_CellRenderList[i]		v = Cells[k]				love.graphics.setColor(v.Color[0], v.Color[1], v.Color[2], 0.2)		love.graphics.draw(LightTexture, v.ix, v.iy, 0, LS, LS, LW/2, LW/2)	end	]]		love.graphics.setColor(1, 1, 1)	love.graphics.rectangle("line", 10, 10, 0.24, 0.24)	--------------------------	-- GUI		Camera:detach()		--love.graphics.print("Cell CT: " .. ModuleData.CellCount.." Debris CT: "..ModuleData.DebrisCount, 15, 15)		local Msg = love.thread.getChannel("Thread Times"):pop()	if Msg ~= nil then		LastThreadTime = Msg	end	love.graphics.print("FPS: " .. love.timer.getFPS() .. " " .. LastThreadTime, 15, 15)	love.graphics.print("CAM: " .. math.floor(Camera.x) .. " - " .. math.floor(Camera.y), 15, 30)		--love.graphics.setCanvas()		local sw = love.graphics.getWidth()	local sh = love.graphics.getHeight()	local dsx = sw / MonitorTexture:getWidth()	local dsy = sh / MonitorTexture:getHeight()			if GUI.StartupPlayed then		--love.graphics.setCanvas(GameCanvas)		--GameEffect(function()			--GUI.DrawGameScreen(MonitorCanvas)		--end)		GUI.DrawHUD(_GlobalDT)	else		--ScreenEffect(function()			GUI.DrawStartupScreen(_GlobalDT)		--end)	end	end)	--love.graphics.draw(MonitorTexture, 0, 0, 0, dsx, dsy)			end